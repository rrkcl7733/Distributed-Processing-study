### 람다 lambda calculus

- 함수 표현식을 축약, 추상화
    - 알파-변환  α-conversion
    - 베타-축약  β-reduction
    - 에타-변환  η-conversion

```scala
f(x, y) = x + y
(x, y) = x + y
λxy.x + y

---------------------
val a = (f1 andThen f2 andThen f3)
a(인자)    // f1-f2-f3
val a = (f1 compose f2 compose f3)
a(인자)    //f3-f2-f1
```
### 부분 적용 함수 partial 1
함수의 인자가 일부만 적용된 함수
```scala
def f = (x: Int, y: Int) => x + y
def my(x: Int) = f(x, 2)
// def my = f(2) _     와 동일
my(1)    // 3
------------------------//베스트 방법
def f = (x: Int) => (y: Int) => x + y
def my(x: Int) = f(2)
```
- 커리 함수의 경우가 부분함수를 적용하는 데 유리하다.
- 함수형 프로그래밍에서는 함수 리터럴을 사용한 정의가 일반적.

### 재귀함수
```scala
def gcd(a: Int, b: Int): Int = {
    if(b == 0) a else gcd(b, a % b)
}
```
- 자주 사용되는 개념
- fold, reduce, scan 등의 함수를 사용하기 위해서 반드시 익혀야 함
- 종료 조건을 반드시 명기
- 지나치게 사용하는 경우는 성능 저하. 오버플로우 주의
- `scala.annotation.tailrec` 어노테이션 도움됨